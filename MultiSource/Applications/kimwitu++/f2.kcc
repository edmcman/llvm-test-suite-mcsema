/* translation of file "/home/ed/mcsema-testing/llvm-test-suite/MultiSource/Applications/kimwitu++/inputs/f2.k" */
/* generated by:
 *  @(#)$Author: criswell $
 */
#define KC_FUNCTIONS_f2_k

#include <stdlib.h>
#include "testk.h"
#include "f2.h"
namespace kc { }
using namespace kc;
/* included stuff */
#line 5 "/home/ed/mcsema-testing/llvm-test-suite/MultiSource/Applications/kimwitu++/inputs/f2.k"
#include <iostream>
#include "k.h"
#include "rk.h"
#include "unpk.h"
#include "csgiok.h"

int yyparse();
line TheLine;

#line  24 "f2.kcc"
/* end included stuff */


namespace kc {

#ifndef KC_TRACE_PROVIDED
#define KC_TRACE_PROVIDED(COND,FILE,LINE,NODE) COND
#endif

void printer(const char *s, uview v)
#line 24 "/home/ed/mcsema-testing/llvm-test-suite/MultiSource/Applications/kimwitu++/inputs/f2.k"
{
    std::cout << s;

#line 26 "/home/ed/mcsema-testing/llvm-test-suite/MultiSource/Applications/kimwitu++/inputs/f2.k"
}
#line  41 "f2.kcc"

} // namespace kc
int main(int argc, char **argv)
#line 30 "/home/ed/mcsema-testing/llvm-test-suite/MultiSource/Applications/kimwitu++/inputs/f2.k"
{
    FILE* f;

    std::cout << " RPN Parser and reformatter " << std::endl;

    if (argc==2) {
	f=fopen(argv[1], "r");
	kc::CSGIOread(f, TheLine);
	fclose(f);
    } else yyparse();

    line TheCanonLine=TheLine->rewrite(canon);
    line TheShortLine=TheCanonLine->rewrite(calculate);

    std::cout << "\nInfix notation:\n";
    TheCanonLine->unparse(printer, infix);

    std::cout << "\n\nCanonical postfix notation:\n";
    TheCanonLine->unparse(printer, postfix);

    std::cout << "\n\nCalculated infix notation:\n";
    TheShortLine->unparse(printer, infix);

    std::cout << "\n\nCalculated canonical postfix notation:\n";
    TheShortLine->unparse(printer, postfix);

    std::cout << std::endl;

#line 57 "/home/ed/mcsema-testing/llvm-test-suite/MultiSource/Applications/kimwitu++/inputs/f2.k"
}
#line  76 "f2.kcc"

namespace kc {

} // namespace kc
