/* translation of file(s)
	"/home/ed/mcsema-testing/llvm-test-suite/MultiSource/Applications/kimwitu++/inputs/f3.k"
	"/home/ed/mcsema-testing/llvm-test-suite/MultiSource/Applications/kimwitu++/inputs/f2.k"
	"/home/ed/mcsema-testing/llvm-test-suite/MultiSource/Applications/kimwitu++/inputs/f1.k"
 */
/* generated by:
 *  @(#)$Author: criswell $
 */
#define KC_TYPES

#include "testk.h"
#include <stdio.h>
#include <ctype.h>
#include <string>
#include <sys/types.h>
#include <stdlib.h>

#ifdef _MSC_VER
#pragma warning( disable : 4786 )
#endif
#include <new>
#include <set>
#include <list>
#include <algorithm>

#if !defined(USE_HASHSET) && (defined(__GNUC__) || defined(__ICC) || defined(__ECC)) \
&& !defined(DONT_USE_HASHSET)
#  define USE_HASHSET
#endif
#ifdef USE_HASHSET
#  if defined(__GNUC__) && __GNUC__>2
#    include <ext/hash_set>
#  else
#    include <hash_set>
#  endif
#endif

using namespace std;

namespace kc {

inline bool
ht_less(casestring p1, casestring p2){
    return kc_strcmp(p1->name, p2->name)<0;
}

inline bool
ht_less(nocasestring p1, nocasestring p2){
    return kc_strcasecmp(p1->name, p2->name)<0;
}

inline bool
ht_less(real p1, real p2){
    return p1->value < p2->value;
}

inline bool
ht_less(integer p1, integer p2){
    return p1->value < p2->value;
}

inline bool
ht_less(voidptr p1, voidptr p2){
    return p1->pointer < p2->pointer;
}

bool
ht_less(abstract_phylum p1, abstract_phylum p2)
{
    enum_operators prod_sel=p1->prod_sel();
    enum_operators prod_sel2=p2->prod_sel();
    if(prod_sel<prod_sel2)
	return true;
    if(prod_sel>prod_sel2)
	return false;
    switch(prod_sel) {
	case sel_NoCaseStr:
	    return ht_less(static_cast<nocasestring>(p1),static_cast<nocasestring>(p2));
	case sel__Str:
	    return ht_less(static_cast<casestring>(p1),static_cast<casestring>(p2));
	case sel__Real:
	    return ht_less(static_cast<real>(p1),static_cast<real>(p2));
	case sel__Int:
	    return ht_less(static_cast<integer>(p1),static_cast<integer>(p2));
	case sel__VoidPtr:
	    return ht_less(static_cast<voidptr>(p1),static_cast<voidptr>(p2));
	default: {
	    int i=0;
	    bool still_unique = kc_storageclass_still_uniq[phylum_info[p1->phylum()].uniq_stored];
	    abstract_phylum sub1=0;
	    do {
		sub1=p1->subphylum(i);
		abstract_phylum sub2=p2->subphylum(i);
		if(still_unique) {
		    if(sub1<sub2)
			return true;
		    if(sub2<sub1)
			return false;
		}
		else {
		    if(ht_less(sub1, sub2))
			return true;
		    if(ht_less(sub2, sub1))
			return false;
		}
		++i;
	    } while(sub1);
	}
    }
    return false;
}

template<typename T>
class phylum_less : std::binary_function<T, T, bool>
{
    public:
    bool operator()(const T& X, const T& Y) const
	{ return ht_less(X,Y); }
};

inline void deletefun(c_abstract_phylum t){
    delete const_cast<abstract_phylum>(t);
}


#ifdef USE_HASHSET
struct hashitem {
    size_t hashvalue;
    casestring contents;
    hashitem(casestring cs): contents(cs) {
	unsigned long h = 0;
	kc_char_t const *s = cs->name;
	for ( ; *s; ++s)
	    h = 5*h + *s;
	hashvalue=(size_t)h;
    }
};

inline void deletefunhashitem(hashitem t) {
    delete t.contents;
}

#  ifdef __GNUC__
struct eq_hashitem { bool operator()(hashitem hi1, hashitem hi2) const {
	return kc_strcmp(hi1.contents->name, hi2.contents->name) == 0; } };

struct hash_hashitem { size_t operator()(hashitem hi) const {
	return hi.hashvalue; } };

#  else
struct comp_hashitem {
    enum { bucket_size = 4, min_buckets = 8 };
    // bucket_size and min_buckets are just guesses
    size_t operator()(const hashitem hi) const {
	return hi.hashvalue; }
    bool operator()(const hashitem hi1, const hashitem hi2) const {
	return kc_strcmp(hi1.contents->name, hi2.contents->name) < 0; }
};
#  endif // Whether gcc or icc
#endif // Whether hash or not

struct hashtable_level
{
    hashtable_level(bool cod = true): clean_on_destruction(cod) { }
    void clear(bool free_entries=true) {
	if(free_entries)
	    clear_entries();
	_casestring.clear();
	_nocasestring.clear();
	_integer.clear();
	_real.clear();
	_voidptr.clear();
	_abstract_phylum.clear();
    }
    void clear_entries() {
#ifdef USE_HASHSET
	std::for_each(_casestring.begin(),_casestring.end(),deletefunhashitem);
#else
	std::for_each(_casestring.begin(),_casestring.end(),deletefun);
#endif
	std::for_each(_nocasestring.begin(),_nocasestring.end(),deletefun);
	std::for_each(_integer.begin(),_integer.end(),deletefun);
	std::for_each(_real.begin(),_real.end(),deletefun);
	std::for_each(_voidptr.begin(),_voidptr.end(),deletefun);
	std::for_each(_abstract_phylum.begin(),_abstract_phylum.end(),deletefun);
    }
    ~hashtable_level() {
	clear(clean_on_destruction);
    }
    abstract_phylum check_insert(abstract_phylum t) {
	return *_abstract_phylum.insert(t).first;
    }
    casestring check_insert(casestring t) {
#ifdef USE_HASHSET
	return (*_casestring.insert(hashitem(t)).first).contents;
#else
	return *_casestring.insert(t).first;
#endif
    }
    nocasestring check_insert(nocasestring t) {
	return *_nocasestring.insert(t).first;
    }
    integer check_insert(integer t) {
	return *_integer.insert(t).first;
    }
    real check_insert(real t) {
	return *_real.insert(t).first;
    }
    voidptr check_insert(voidptr t) {
	return *_voidptr.insert(t).first;
    }
private:
    bool clean_on_destruction;
#ifdef USE_HASHSET
#  ifdef __GNUC__
#    if __GNUC__==2 || (__GNUC__==3 && __GNUC_MINOR__==0)
    std::hash_set<hashitem, hash_hashitem, eq_hashitem> _casestring;
#    else
    __gnu_cxx::hash_set<hashitem, hash_hashitem, eq_hashitem> _casestring;
#    endif
#  else
    std::hash_set<hashitem, comp_hashitem> _casestring;
#  endif
#else
    std::set<casestring, phylum_less<casestring> > _casestring;
#endif
    std::set<nocasestring, phylum_less<nocasestring> > _nocasestring;
    std::set<integer, phylum_less<integer> > _integer;
    std::set<real, phylum_less<real> > _real;
    std::set<voidptr, phylum_less<voidptr> > _voidptr;
    std::set<abstract_phylum, phylum_less<abstract_phylum> > _abstract_phylum;
};

class hashtable_stack: public std::list<hashtable_level> {
public:
    hashtable_stack(): _pos(begin()) { }

    void inc_level() { _pos=insert(_pos, hashtable_level()); }
    void dec_level() { if(valid() && _pos!=end()) ++_pos; }
    void free_level() { if(_pos!=begin()) { erase(begin(),_pos);_pos=begin(); } }

    bool valid() const { return !empty(); }
    hashtable_level& get_level() { return *_pos; }

    template<typename T>
    T check_insert(T t) {
	return dynamic_cast<T>((*_pos).check_insert(t));
    }
private:
    iterator _pos;
};

class hashtable_struct_t {
public:
    // don't clean _static_level on destruction (program ends)
    hashtable_struct_t(): _static_level(false), _to_be_freed(false),  _dynamic(false) { }

    template <typename T>
    T ht_check_insert(T t) {
	if(_dynamic && _dynamic_level.valid())
	    return _dynamic_level.check_insert(t);
	else
	    return dynamic_cast<T>(_static_level.check_insert(t));
    }
    void ht_static() {_dynamic=false; }
    void ht_dynamic() {
	_dynamic=true;
	if(!_dynamic_level.valid())
	    _dynamic_level.inc_level();
    }
    void ht_inc_level() { _dynamic_level.inc_level(); }
    void ht_dec_level() { _dynamic_level.dec_level(); }
    void ht_free_level() { _dynamic_level.free_level(); }
    void ht_clear() { _static_level.clear(); _dynamic_level.clear(); _dynamic=false; }

    bool to_be_freed() { return _to_be_freed; }
    void set_to_be_freed(bool b=true) { _to_be_freed=b; }
private:
    hashtable_level _static_level;
    hashtable_stack _dynamic_level;
    bool _to_be_freed; /* should be true for dynamic, false for statically allocated structures */
    bool _dynamic;
};

impl_nocasestring_NoCaseStr::impl_nocasestring_NoCaseStr(const kc_char_t* _name) : name(_name) { }
void impl_nocasestring_NoCaseStr::make_own(int length) {
    kc_char_t *newname=new kc_char_t[length+1];
    for (int i=0; i < length && name[i]; ++i)
    newname[i] = kc_tolower(name[i]);
    newname[length]=0;
    name=newname;
}

impl_casestring__Str::impl_casestring__Str(const kc_char_t* _name) : name(_name) { }
void impl_casestring__Str::make_own(int length) {
    kc_char_t *newname=kc_strncpy(new kc_char_t[length+1],name,length);
    newname[length]=0;
    name=newname;
}
abstract_phylum impl_expression_Div2::subphylum(int no) const
{
    switch(no){
	case 0: return expression_1;
	case 1: return casestring_1;
	case 2: return expression_2;
    }
    return 0;
}
abstract_phylum impl_expression_Div::subphylum(int no) const
{
    switch(no){
	case 0: return expression_1;
	case 1: return expression_2;
    }
    return 0;
}
abstract_phylum impl_expression_Minus::subphylum(int no) const
{
    switch(no){
	case 0: return expression_1;
	case 1: return expression_2;
    }
    return 0;
}
abstract_phylum impl_expression_Mul::subphylum(int no) const
{
    switch(no){
	case 0: return expression_1;
	case 1: return expression_2;
    }
    return 0;
}
abstract_phylum impl_expression_Plus::subphylum(int no) const
{
    switch(no){
	case 0: return expression_1;
	case 1: return expression_2;
    }
    return 0;
}
abstract_phylum impl_expression_Term::subphylum(int no) const
{
    switch(no){
	case 0: return term_1;
    }
    return 0;
}
abstract_phylum impl_term_Ident::subphylum(int no) const
{
    switch(no){
	case 0: return casestring_1;
    }
    return 0;
}
abstract_phylum impl_term_Number::subphylum(int no) const
{
    switch(no){
	case 0: return integer_1;
    }
    return 0;
}
abstract_phylum impl_line_Line::subphylum(int no) const
{
    switch(no){
	case 0: return expression_1;
    }
    return 0;
}
void impl_expression_Div2::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = expression_1 = dynamic_cast<expression>(val);break;
	case 1: newval = casestring_1 = dynamic_cast<casestring>(val);break;
	case 2: newval = expression_2 = dynamic_cast<expression>(val);break;
    }
    assertNonNull(newval);
}
void impl_expression_Div::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = expression_1 = dynamic_cast<expression>(val);break;
	case 1: newval = expression_2 = dynamic_cast<expression>(val);break;
    }
    assertNonNull(newval);
}
void impl_expression_Minus::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = expression_1 = dynamic_cast<expression>(val);break;
	case 1: newval = expression_2 = dynamic_cast<expression>(val);break;
    }
    assertNonNull(newval);
}
void impl_expression_Mul::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = expression_1 = dynamic_cast<expression>(val);break;
	case 1: newval = expression_2 = dynamic_cast<expression>(val);break;
    }
    assertNonNull(newval);
}
void impl_expression_Plus::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = expression_1 = dynamic_cast<expression>(val);break;
	case 1: newval = expression_2 = dynamic_cast<expression>(val);break;
    }
    assertNonNull(newval);
}
void impl_expression_Term::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = term_1 = dynamic_cast<term>(val);break;
    }
    assertNonNull(newval);
}
void impl_term_Ident::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = casestring_1 = dynamic_cast<casestring>(val);break;
    }
    assertNonNull(newval);
}
void impl_term_Number::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = integer_1 = dynamic_cast<integer>(val);break;
    }
    assertNonNull(newval);
}
void impl_line_Line::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = expression_1 = dynamic_cast<expression>(val);break;
    }
    assertNonNull(newval);
}

void
copy_attributes(enum_phyla copyPhy, c_abstract_phylum kc_p1, abstract_phylum kc_p2)
{
    switch(copyPhy) {
    case one_before_first_phylum: // just to avoid a warning about missing case if empty
    default:
	break; // it's alright, no attributes to copy
    }
    enum_operators copyOp=kc_p1->prod_sel();
    for (int i=operator_info[copyOp].no_attrs-1; i>=0; --i)
	attributeOf(kc_p2, i)=attributeOf(const_cast<abstract_phylum>(kc_p1), i);
}

KC_PHYLUM_INFO phylum_info[] = {
    { "", one_before_first_operator, one_before_first_operator, (kc_storageclass_t)0 }, /* dummy element */
    { "nocasestring", sel_NoCaseStr, sel_NoCaseStr, uniq },
    { "casestring", sel__Str, sel__Str, uniq },
    { "real", sel__Real, sel__Real, uniq },
    { "integer", sel__Int, sel__Int, uniq },
    { "voidptr", sel__VoidPtr, sel__VoidPtr, uniq },
    { "line", sel_Line, sel_Line, kc_not_uniq },
    { "term", sel_Number, sel_Ident, kc_not_uniq },
    { "expression", sel_Term, sel_Div2, kc_not_uniq },
    { "", one_before_first_operator, one_before_first_operator, (kc_storageclass_t)0 } /* last element */
};

static enum_phyla kc_subphyla_Line[] = { phylum_expression };
static enum_phyla kc_subphyla_Number[] = { phylum_integer };
static enum_phyla kc_subphyla_Ident[] = { phylum_casestring };
static enum_phyla kc_subphyla_Term[] = { phylum_term };
static enum_phyla kc_subphyla_Plus[] = { phylum_expression, phylum_expression };
static enum_phyla kc_subphyla_Mul[] = { phylum_expression, phylum_expression };
static enum_phyla kc_subphyla_Minus[] = { phylum_expression, phylum_expression };
static enum_phyla kc_subphyla_Div[] = { phylum_expression, phylum_expression };
static enum_phyla kc_subphyla_Div2[] = { phylum_expression, phylum_casestring, phylum_expression };


KC_OPERATOR_INFO operator_info[] = {
    { "", 0, 0, one_before_first_phylum, 0, 0, 0, 0 }, /* dummy element */
    { "NoCaseStr", 0, true, phylum_nocasestring, 0, 0, 0, sizeof(impl_nocasestring_NoCaseStr) },
    { "_Str", 0, true, phylum_casestring, 0, 0, 0, sizeof(impl_casestring__Str) },
    { "_Real", 0, true, phylum_real, 0, 0, 0, sizeof(impl_real__Real) },
    { "_Int", 0, true, phylum_integer, 0, 0, 0, sizeof(impl_integer__Int) },
    { "_VoidPtr", 0, true, phylum_voidptr, 0, 0, 0, sizeof(impl_voidptr__VoidPtr) },
    { "Line", 1, false, phylum_line, kc_subphyla_Line, 0, 0, sizeof(impl_line_Line) },
    { "Number", 1, false, phylum_term, kc_subphyla_Number, 0, 0, sizeof(impl_term_Number) },
    { "Ident", 1, false, phylum_term, kc_subphyla_Ident, 0, 0, sizeof(impl_term_Ident) },
    { "Term", 1, false, phylum_expression, kc_subphyla_Term, 0, 0, sizeof(impl_expression_Term) },
    { "Plus", 2, false, phylum_expression, kc_subphyla_Plus, 0, 0, sizeof(impl_expression_Plus) },
    { "Mul", 2, false, phylum_expression, kc_subphyla_Mul, 0, 0, sizeof(impl_expression_Mul) },
    { "Minus", 2, false, phylum_expression, kc_subphyla_Minus, 0, 0, sizeof(impl_expression_Minus) },
    { "Div", 2, false, phylum_expression, kc_subphyla_Div, 0, 0, sizeof(impl_expression_Div) },
    { "Div2", 3, false, phylum_expression, kc_subphyla_Div2, 0, 0, sizeof(impl_expression_Div2) },
    { "", 0, 0, one_before_first_phylum, 0, 0, 0, 0 } /* last element */
};

static enum_phyla phylumstorageclass_uniq[] = { one_before_first_phylum, phylum_nocasestring, phylum_casestring, phylum_real, phylum_integer, phylum_voidptr, last_phylum };

KC_UNIQ_INFO kc_UniqInfo[] = {
    (KC_UNIQ_INFO)0,
    phylumstorageclass_uniq
};

} // namespace kc

namespace kc {

void
kc_no_default_in_with( const char *kc_func, int kc_line, const char *kc_file )
{
    fflush(stdout);
#ifdef _AFX
    USES_CONVERSION;
    const _TCHAR* format=A2CT(KC_NO_DEFAULT_IN_WITH);
    const _TCHAR* tkc_func=A2CT(kc_func);
    const _TCHAR* tkc_file=A2CT(kc_file);
    TRACE( format, tkc_func, tkc_file, kc_line );
#ifdef _DEBUG
    if (AfxAssertFailedLine(kc_file, kc_line))
#endif
	AfxDebugBreak();
#else
    fprintf( stderr, KC_NO_DEFAULT_IN_WITH, kc_func, kc_file, kc_line );
#ifndef KC_NODEFAULT_NO_ABORT
    abort();
#else
    exit( 1 );
#endif
#endif
}

void
kc_returnless_function( const char *kc_func, int kc_line, const char *kc_file )
{
    fflush(stdout);
#ifdef _AFX
    USES_CONVERSION;
    const _TCHAR* format=_T("Internal Error: function %s does not return a value, at %s:%d");
    const _TCHAR* tkc_func=A2CT(kc_func);
    const _TCHAR* tkc_file=A2CT(kc_file);
    TRACE( format, tkc_func, tkc_file, kc_line );
#ifdef _DEBUG
    if (AfxAssertFailedLine(kc_file, kc_line))
#endif
	AfxDebugBreak();
#else
    fprintf( stderr, "Internal Error: function %s does not return a value, at %s:%d", kc_func, kc_file, kc_line );
#ifndef KC_NODEFAULT_NO_ABORT
    abort();
#else
    exit( 1 );
#endif
#endif
}

void
kc_assertionFailed(const char *kc_fn, int kc_l)
{
    fflush(stdout);
#ifdef _AFX
    USES_CONVERSION;
    const _TCHAR* format=_T("Internal Error: Assertion failed at %s:%d\n");
    const _TCHAR* tkc_func=A2CT(kc_fn);
    TRACE( format, tkc_func, kc_l );
#ifdef _DEBUG
    if (AfxAssertFailedLine(kc_fn, kc_l))
#endif
	AfxDebugBreak();
#else
    fprintf( stderr, "Internal Error: Assertion failed at %s:%d\n", kc_fn, kc_l );
#ifndef KC_ASSERT_NO_ABORT
    abort();
#else
    exit( 1 );
#endif
#endif
}

void
kc_assertionReasonFailed(const char *kc_fn, int kc_l, const char *kc_s)
{
    fflush(stdout);
#ifdef _AFX
    USES_CONVERSION;
    const _TCHAR* format=_T("Internal Error: Assertion failed at file %s:%d: %s\n");
    const _TCHAR* tkc_func=A2CT(kc_fn);
    const _TCHAR* tkc_s=A2CT(kc_s);
    TRACE( format, tkc_func, kc_l, tkc_s );
#ifdef _DEBUG
    if (AfxAssertFailedLine(kc_fn, kc_l))
#endif
	AfxDebugBreak();
#else
    fprintf( stderr, "Internal Error: Assertion failed at file %s:%d: %s\n", kc_fn, kc_l, kc_s );
#ifndef KC_ASSERT_NO_ABORT
    abort();
#else
    exit( 1 );
#endif
#endif
}

void
kc_assertionNonNullFailed(const char *kc_fn, int kc_l, const char *kc_str)
{
    fflush(stdout);
#ifdef _AFX
    USES_CONVERSION;
    const _TCHAR* format=_T("Internal Error: Assertion failed at %s:%d: pointer %s is NULL\n");
    const _TCHAR* tkc_func=A2CT(kc_fn);
    const _TCHAR* tkc_s=A2CT(kc_str);
    TRACE( format , tkc_func, kc_l, tkc_s);
#ifdef _DEBUG
    if (AfxAssertFailedLine(kc_fn, kc_l))
#endif
	AfxDebugBreak();
#else
    fprintf( stderr, "Internal Error: Assertion failed at %s:%d: pointer %s is NULL\n", kc_fn, kc_l, kc_str );
#ifndef KC_ASSERT_NO_ABORT
    abort();
#else
    exit( 1 );
#endif
#endif
}

void
kc_assertionOperatorInPhylumFailed(int kc_op, const char *kc_str1, const char *kc_str2, const char *kc_phy, const char *kc_fn, int kc_l)
{
    fflush(stdout);
#ifdef _AFX
    USES_CONVERSION;
    const _TCHAR* format=_T("Internal Error: Assertion failed at %s:%d: illegal value for (%s) %s%s: %d not a valid operator\n");
    const _TCHAR* tkc_func=A2CT(kc_fn);
    const _TCHAR* tkc_s1=A2CT(kc_str1);
    const _TCHAR* tkc_s2=A2CT(kc_str2);
    const _TCHAR* tname=A2CT(kc_phy);
    if ((kc_op <= one_before_first_operator) || (kc_op >= last_operator)) {
	TRACE (format, tkc_func, kc_l, tname, tkc_s1, tkc_s2, kc_op );
    } else {
	format=_T("Internal Error: Assertion failed at %s:%d: illegal value for (%s) %s%s: %s (%d) is a value of %s\n");
	const _TCHAR* tname2=A2CT(operator_info[kc_op].name);
	const _TCHAR* tname3=A2CT(phylum_info[operator_info[kc_op].phylum].name);
	TRACE(format,tkc_func, kc_l, tname, tkc_s1, tkc_s2, tname2, kc_op, tname3 );
    }
#ifdef _DEBUG
    if (AfxAssertFailedLine(kc_fn, kc_l))
#endif
	AfxDebugBreak();
#else
    if ((kc_op <= one_before_first_operator) || (kc_op >= last_operator)) {
	fprintf( stderr, "Internal Error: Assertion failed at %s:%d: illegal value for (%s) %s%s: %d not a valid operator\n",
	    kc_fn, kc_l, kc_phy, kc_str1, kc_str2, kc_op );
    } else {
	fprintf( stderr, "Internal Error: Assertion failed at %s:%d: illegal value for (%s) %s%s: %s (%d) is a value of %s\n",
	    kc_fn, kc_l, kc_phy, kc_str1, kc_str2, operator_info[kc_op].name, kc_op, phylum_info[operator_info[kc_op].phylum].name );
    }
#ifndef KC_ASSERT_NO_ABORT
    abort();
#else
    exit( 1 );
#endif
#endif
}

void kc_invalid_operator( const char *kc_func_prefix, enum_phyla kc_phy, int kc_line, const char *kc_file, enum_operators kc_oper )
{
    fflush(stdout);
#ifdef _AFX
    USES_CONVERSION;
    const _TCHAR* format=_T("Internal Error: invalid operator code in %s%s at %s:%d: %s\n");
    const _TCHAR* tkc_func=A2CT(kc_func_prefix);
    const _TCHAR* tkc_file=A2CT(kc_file);
    const _TCHAR* ts1=A2CT(phylumname_or_error( kc_phy ));
    const _TCHAR* ts2=A2CT(kc_operatorname_or_error( kc_oper ));
    TRACE( format, tkc_func, ts1, tkc_file, kc_line, ts2);
#ifdef _DEBUG
    if (AfxAssertFailedLine(kc_file, kc_line))
#endif
	AfxDebugBreak();
#else
    fprintf( stderr, "Internal Error: invalid operator code in %s%s at %s:%d: %s\n", kc_func_prefix, phylumname_or_error( kc_phy ), kc_file, kc_line, kc_operatorname_or_error( kc_oper ));
#ifndef KC_INVALID_OPERATOR_NO_ABORT
    abort();
#else
    exit( 1 );
#endif
#endif
}
const enum_phyla impl_nocasestring::phylum_sel_ = phylum_nocasestring;
const enum_phyla impl_casestring::phylum_sel_ = phylum_casestring;
const enum_phyla impl_real::phylum_sel_ = phylum_real;
impl_real__Real::impl_real__Real(REAL _value)
    : value(_value) { }
const enum_phyla impl_integer::phylum_sel_ = phylum_integer;
impl_integer__Int::impl_integer__Int(INTEGER _value)
    : value(_value) { }
const enum_phyla impl_voidptr::phylum_sel_ = phylum_voidptr;
impl_voidptr__VoidPtr::impl_voidptr__VoidPtr(void* _pointer)
    : pointer(_pointer) { }
const enum_phyla impl_line::phylum_sel_ = phylum_line;
impl_line_Line::impl_line_Line(expression _expression_1)
    : expression_1(_expression_1) { }
const enum_phyla impl_term::phylum_sel_ = phylum_term;
impl_term_Ident::impl_term_Ident(casestring _casestring_1)
    : casestring_1(_casestring_1) { }
impl_term_Number::impl_term_Number(integer _integer_1)
    : integer_1(_integer_1) { }
const enum_phyla impl_expression::phylum_sel_ = phylum_expression;
impl_expression_Div2::impl_expression_Div2(expression _expression_1, casestring _casestring_1, expression _expression_2)
    : expression_1(_expression_1), casestring_1(_casestring_1), expression_2(_expression_2) { }
impl_expression_Div::impl_expression_Div(expression _expression_1, expression _expression_2)
    : expression_1(_expression_1), expression_2(_expression_2) { }
impl_expression_Minus::impl_expression_Minus(expression _expression_1, expression _expression_2)
    : expression_1(_expression_1), expression_2(_expression_2) { }
impl_expression_Mul::impl_expression_Mul(expression _expression_1, expression _expression_2)
    : expression_1(_expression_1), expression_2(_expression_2) { }
impl_expression_Plus::impl_expression_Plus(expression _expression_1, expression _expression_2)
    : expression_1(_expression_1), expression_2(_expression_2) { }
impl_expression_Term::impl_expression_Term(term _term_1)
    : term_1(_term_1) { }

#ifdef KC_STATISTICS
KC_OPERATOR_STATISTICS operator_statistics[KC_NO_OF_OPERATORS];
static int kc_casestring_strlen =0;
static int kc_nocasestring_strlen =0;
#  define KC_COLLECT_STATS0(v) v
#else
#  define KC_COLLECT_STATS0(v)
#endif

#ifndef KC_CREATE_STATS
#  define KC_CREATE_STATS(oper) operator_statistics[oper].created++;
#endif
#ifndef KC_EXISTINGNOTFOUND_STATS
#  define KC_EXISTINGNOTFOUND_STATS(oper) operator_statistics[oper].existing_not_found++;
#endif

#ifndef KC_FREE_CALLED_STATS
#  define KC_FREE_CALLED_STATS(oper,rec) operator_statistics[oper].free_called[(rec?true:false)]++;
#endif

#ifndef KC_FREED_STATS
#  define KC_FREED_STATS(oper,rec) operator_statistics[oper].freed[(rec?true:false)]++;
#endif
static hashtable_struct_t kc_not_uniq_static_hashtable;
static hashtable_struct_t uniq_static_hashtable;

bool kc_storageclass_still_uniq[] = {
    true, true };

hashtable_t hashtables[] = {
    &kc_not_uniq_static_hashtable,
    &uniq_static_hashtable,
};

const char* kc_storageclassnames[] = { "kc_not_uniq", "uniq" };

namespace { // all local to k.cc


} // namespace

enum_phyla
impl_abstract_phylum::phylum() const {
    return operator_info[prod_sel()].phylum;
}

const char*
impl_abstract_phylum::phylum_name() const {
    return phylum_info[phylum()].name;
}

const char*
impl_abstract_phylum::op_name() const {
    return operator_info[prod_sel()].name;
}

casestring
mkcasestring(const kc_char_t *kc_s, int length)
{
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel__Str));

    casestring kc_x=new impl_casestring__Str(kc_s);
    if(length>=0) 
	kc_x->make_own(length);

    casestring unique_kc_x=hashtables[uniq]->ht_check_insert((casestring)kc_x);
    if(unique_kc_x!=kc_x) {
	if(length<0) 
	    kc_x->name=0;

	delete kc_x;
	kc_x=unique_kc_x;
    } else {
	KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel__Str));
	if(length<0) 
	    kc_x->make_own(static_cast<int>(kc_strlen(kc_s)));

	kc_x->post_create();
    }
    return kc_x;
}

nocasestring
mknocasestring(const kc_char_t *kc_s, int length)
{
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_NoCaseStr));

    nocasestring kc_x=new impl_nocasestring_NoCaseStr(kc_s);
    if(length>=0)
	kc_x->make_own(length);
    nocasestring unique_kc_x=hashtables[uniq]->ht_check_insert((nocasestring)kc_x);
    if(unique_kc_x!=kc_x) {
	if(length<0)
	    kc_x->name=0;
	delete kc_x;
	kc_x=unique_kc_x;
    } else {
	KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_NoCaseStr));
	if(length<0)
	    kc_x->make_own(static_cast<int>(kc_strlen(kc_s)));
	kc_x->post_create();
    }

    return kc_x;
}

integer
mkinteger(const INTEGER kc_i)
{
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel__Int));

    integer kc_x =new impl_integer__Int(kc_i);
    integer unique_kc_x=hashtables[uniq]->ht_check_insert(kc_x);
    if(unique_kc_x!=kc_x) {
	delete kc_x;
	kc_x=unique_kc_x;
    } else {
	KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel__Int));
	kc_x->post_create();
    }

    return kc_x;
}

real
mkreal(const REAL kc_r)
{
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel__Real));

    real kc_x=new impl_real__Real(kc_r);
    real unique_kc_x=hashtables[uniq]->ht_check_insert(kc_x);
    if(unique_kc_x!=kc_x) {
	delete kc_x;
	kc_x=unique_kc_x;
    } else {
	KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel__Real));
	kc_x->post_create();
    }

    return kc_x;
}

voidptr
mkvoidptr(void *kc_p)
{
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel__VoidPtr));
    voidptr kc_x=new impl_voidptr__VoidPtr(kc_p);
    voidptr unique_kc_x=hashtables[uniq]->ht_check_insert(kc_x);
    if(unique_kc_x!=kc_x) {
	delete kc_x;
	kc_x=unique_kc_x;
    } else {
	KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel__VoidPtr));
	kc_x->post_create();
    }
    return kc_x;
}

impl_line_Line*
Line(expression _expression_1) {
    assertPhylum(_expression_1, phylum_expression);
    line kc_x = new impl_line_Line(_expression_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_Line));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_Line));
    kc_x->post_create();
    return static_cast<impl_line_Line*>(kc_x);
}

impl_term_Number*
Number(integer _integer_1) {
    assertPhylum(_integer_1, phylum_integer);
    term kc_x = new impl_term_Number(_integer_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_Number));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_Number));
    kc_x->post_create();
    return static_cast<impl_term_Number*>(kc_x);
}

impl_term_Ident*
Ident(casestring _casestring_1) {
    assertPhylum(_casestring_1, phylum_casestring);
    term kc_x = new impl_term_Ident(_casestring_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_Ident));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_Ident));
    kc_x->post_create();
    return static_cast<impl_term_Ident*>(kc_x);
}

impl_expression_Term*
Term(term _term_1) {
    assertPhylum(_term_1, phylum_term);
    expression kc_x = new impl_expression_Term(_term_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_Term));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_Term));
    kc_x->post_create();
    return static_cast<impl_expression_Term*>(kc_x);
}

impl_expression_Plus*
Plus(expression _expression_1, expression _expression_2) {
    assertPhylum(_expression_1, phylum_expression);
    assertPhylum(_expression_2, phylum_expression);
    expression kc_x = new impl_expression_Plus(_expression_1, _expression_2);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_Plus));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_Plus));
    kc_x->post_create();
    return static_cast<impl_expression_Plus*>(kc_x);
}

impl_expression_Mul*
Mul(expression _expression_1, expression _expression_2) {
    assertPhylum(_expression_1, phylum_expression);
    assertPhylum(_expression_2, phylum_expression);
    expression kc_x = new impl_expression_Mul(_expression_1, _expression_2);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_Mul));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_Mul));
    kc_x->post_create();
    return static_cast<impl_expression_Mul*>(kc_x);
}

impl_expression_Minus*
Minus(expression _expression_1, expression _expression_2) {
    assertPhylum(_expression_1, phylum_expression);
    assertPhylum(_expression_2, phylum_expression);
    expression kc_x = new impl_expression_Minus(_expression_1, _expression_2);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_Minus));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_Minus));
    kc_x->post_create();
    return static_cast<impl_expression_Minus*>(kc_x);
}

impl_expression_Div*
Div(expression _expression_1, expression _expression_2) {
    assertPhylum(_expression_1, phylum_expression);
    assertPhylum(_expression_2, phylum_expression);
    expression kc_x = new impl_expression_Div(_expression_1, _expression_2);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_Div));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_Div));
    kc_x->post_create();
    return static_cast<impl_expression_Div*>(kc_x);
}

impl_expression_Div2*
Div2(expression _expression_1, casestring _casestring_1, expression _expression_2) {
    assertPhylum(_expression_1, phylum_expression);
    assertPhylum(_casestring_1, phylum_casestring);
    assertPhylum(_expression_2, phylum_expression);
    expression kc_x = new impl_expression_Div2(_expression_1, _casestring_1, _expression_2);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_Div2));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_Div2));
    kc_x->post_create();
    return static_cast<impl_expression_Div2*>(kc_x);
}


abstract_phylum
kc_create(enum_operators createOp, abstract_phylum kc_p1, abstract_phylum kc_p2, abstract_phylum kc_p3)
{
    switch(createOp) {
    case sel__VoidPtr:
    case sel__Int:
    case sel__Real:
    case sel__Str:
    case sel_NoCaseStr:
	assertionFailed("Cannot create this kind of phylum - predefined phyla must be handled seperately");break;
    case sel_Div2:
	return Div2(phylum_cast<expression>(kc_p1), phylum_cast<casestring>(kc_p2), phylum_cast<expression>(kc_p3));
    case sel_Div:
	return Div(phylum_cast<expression>(kc_p1), phylum_cast<expression>(kc_p2));
    case sel_Minus:
	return Minus(phylum_cast<expression>(kc_p1), phylum_cast<expression>(kc_p2));
    case sel_Mul:
	return Mul(phylum_cast<expression>(kc_p1), phylum_cast<expression>(kc_p2));
    case sel_Plus:
	return Plus(phylum_cast<expression>(kc_p1), phylum_cast<expression>(kc_p2));
    case sel_Term:
	return Term(phylum_cast<term>(kc_p1));
    case sel_Ident:
	return Ident(phylum_cast<casestring>(kc_p1));
    case sel_Number:
	return Number(phylum_cast<integer>(kc_p1));
    case sel_Line:
	return Line(phylum_cast<expression>(kc_p1));
    default:
	assertionFailed("Cannot create this kind of phylum - unkown operator id");
    }
    NORETURN
}

abstract_phylum&
attributeOf(abstract_phylum kc_p, int no)
{
    assertionFailed("Cannot select attribute for this kind of phylum - has no attributes");
    NORETURN
}

abstract_phylum
impl_abstract_phylum::subphylum(int) const
{
    return 0;
}

void
impl_abstract_phylum::set_subphylum(int,abstract_phylum)
{
}

void
impl_abstract_phylum::free(bool kc_rec)
{
    KC_COLLECT_STATS0(KC_FREE_CALLED_STATS(prod_sel(), kc_rec));
    if (!phylum_info[phylum()].uniq_stored) {
	if (kc_rec) {
	    abstract_phylum son;
	    for (int kc_i=0; (son = subphylum(kc_i)); kc_i++)
	    {
		if (son!=0) son->free(kc_rec);
		son=0;
	    }
	}
	KC_COLLECT_STATS0(KC_FREED_STATS(prod_sel(), kc_rec));
	delete this;
    }
}

bool
impl_abstract_phylum::eq(c_abstract_phylum kc_p2) const
{
    if (this == kc_p2)
	return true;
    if (prod_sel() != kc_p2->prod_sel())
	return false;

    int kc_st = phylum_info[phylum()].uniq_stored;
    if (kc_st && kc_storageclass_still_uniq[kc_st])
	return false;

    c_abstract_phylum son1;
    for (int kc_i=0; (son1 = subphylum(kc_i)); kc_i++) {
	if (!son1->eq(kc_p2->subphylum(kc_i)))
	    return false;
    }

    return true;
}

static string kc_indentation = "";
static const char *kc_printformat_not_nullary_open = "%s%s(\n";
static const char *kc_printformat_list_open = "%s%s\n";

static const char *kc_printformat_not_nullary_close = "%s)\n";
static const char *kc_printformat_nullary = "%s%s()\n";

void
impl_abstract_phylum::fprint(FILE*kc_f)
{
    int kc_i;

    if (!kc_f) kc_f = stdout;
    abstract_list al = dynamic_cast<abstract_list>(this);
    if (al != 0 && !al->is_nil()) {
	fprintf(kc_f, kc_printformat_list_open, kc_indentation.c_str(), op_name());
	kc_indentation+="| ";
	subphylum(0)->fprint(kc_f);
	kc_indentation=kc_indentation.substr(0, kc_indentation.length()-2);
	phylum_cast<abstract_list>(subphylum(1))->fprint_list(kc_f);
	kc_indentation=kc_indentation.substr(0, kc_indentation.length()-2);
    } else // not list
	switch(phylum()) {
	case phylum_voidptr:
	    fprintf(kc_f, "%s%p\n", kc_indentation.c_str(), static_cast<voidptr>(this)->pointer);
	    break;
	case phylum_casestring:
	case phylum_nocasestring:
	    fprintf(kc_f, "%s%s\n", kc_indentation.c_str(), static_cast<casestring>(this)->name);
	    break;
	case phylum_integer:
	    fprintf(kc_f, "%s%i\n", kc_indentation.c_str(), static_cast<integer>(this)->value);
	    break;
	case phylum_real:
	    fprintf(kc_f, "%s%f\n", kc_indentation.c_str(), static_cast<real>(this)->value);
	    break;
	default:
	    if (!subphylum(0)) {
		fprintf(kc_f, kc_printformat_nullary, kc_indentation.c_str(), op_name());
	    } else {
		fprintf(kc_f, kc_printformat_not_nullary_open, kc_indentation.c_str(), op_name());
		kc_indentation+="  ";
		abstract_phylum son;
		for (kc_i=0; (son = subphylum(kc_i)); kc_i++) {
		    son->fprint(kc_f);
		}
		kc_indentation=kc_indentation.substr(0, kc_indentation.length()-2);
		fprintf(kc_f, kc_printformat_not_nullary_close, kc_indentation.c_str());
	    }
    }
}

void 
impl_abstract_phylum::print()
{
    fprint(stdout);
}

void 
impl_abstract_list::fprint_list(FILE*kc_f)
{
    if (!kc_f)
	kc_f = stdout;
    if (this->is_nil()) {
	kc_indentation+="`-";
	fprintf(kc_f, kc_printformat_nullary, kc_indentation.c_str(), op_name());
    } else {
	kc_indentation+="|-";
	fprintf(kc_f, kc_printformat_list_open, kc_indentation.c_str(), op_name());
	kc_indentation=kc_indentation.substr(0, kc_indentation.length()-2);
	kc_indentation+="| ";
	subphylum(0)->fprint(kc_f);
	kc_indentation=kc_indentation.substr(0, kc_indentation.length()-2);
	phylum_cast<abstract_list>(subphylum(1))->fprint_list(kc_f);
    }
}

int
impl_abstract_list::length() const
{
    int kc_length = 0;
    c_abstract_phylum kc_p = this;
    while((kc_p = kc_p->subphylum(1)))
	kc_length++;
    return kc_length;
}
void impl_abstract_list::freelist()
{
    abstract_phylum kc_p = this, kc_tmp_p;
    do {
	kc_tmp_p=kc_p->subphylum(1);
	kc_p->free(false);
	kc_p=kc_tmp_p;
    } while(kc_p);
}
abstract_phylum
impl_abstract_list::do_concat(c_abstract_phylum kc_p2, enum_operators mk) const
{
    abstract_phylum next = subphylum(1);
    if(!next)
	return const_cast<abstract_phylum>(kc_p2);
    return kc_create(mk, subphylum(0), static_cast<abstract_list>(next)->do_concat(kc_p2, mk));
}

abstract_phylum
impl_abstract_list::do_reverse(c_abstract_phylum tail, enum_operators mk) const
{
    for (impl_abstract_list const* iterator_ = this; iterator_->subphylum(1) != 0;
	iterator_ = static_cast<impl_abstract_list const*>(iterator_->subphylum(1)) )
    tail = kc_create(mk, iterator_->subphylum(0), const_cast<abstract_phylum>(tail));
    return const_cast<abstract_phylum>(tail);
}

abstract_phylum
impl_abstract_list::last() const
{
    c_abstract_phylum kc_p = this, next = subphylum(1), nextnext;
#ifdef _AFX
    ASSERT(next);
    if(!next)
	return NULL;
#else
    if(!next){
	fflush(stdout);
	fprintf(stderr, "Internal Error: list::last was called with argument Nil%s\n", phylum_name());
	exit(1);
    }
#endif
    while ((nextnext = next->subphylum(1))) {
	kc_p = next;
	next = nextnext;
    }
    return const_cast<abstract_phylum>(kc_p->subphylum(0));/* XXX remove cast */
}

abstract_phylum
impl_abstract_list::do_map(abstract_phylum (*kc_fp)(abstract_phylum), enum_operators mk)
{
    abstract_phylum el = subphylum(0);
    if (!el)
	return this;
    abstract_list next = static_cast<abstract_list>(subphylum(1));
    return kc_create(mk, kc_fp(el), next->do_map(kc_fp, mk));
}

abstract_phylum
impl_abstract_list::do_filter(bool (*kc_fp)(abstract_phylum), enum_operators mk)
{
    abstract_phylum el = subphylum(0);
    if (!el)
	return this;
    abstract_list next = static_cast<abstract_list>(subphylum(1));
    if ((*kc_fp)(el)) {
	return kc_create(mk, el, next->do_filter(kc_fp, mk));
    } else {
	return next->do_filter(kc_fp, mk);
    }
}

abstract_list
impl_abstract_list::do_append(abstract_phylum new_last, abstract_list eol)
{
    abstract_list next = this;
    while (!next->is_nil())
	next = phylum_cast<abstract_list>(next->subphylum(1));
    next->set_subphylum(0, new_last);
    next->set_subphylum(1, eol);
    return next;
}

abstract_phylum
impl_abstract_list::do_merge(abstract_list second,abstract_phylum(*kc_fp)(abstract_phylum,abstract_phylum), enum_operators mk)
{
    abstract_phylum el = subphylum(0);
    if (!el)
	return this;
    abstract_phylum el2 = second->subphylum(0);
    if (!el2)
	return el2;
    abstract_list next = static_cast<abstract_list>(subphylum(1));
    abstract_list next2 = static_cast<abstract_list>(second->subphylum(1));
    return kc_create(mk, kc_fp(el,el2), next->do_merge(next2, kc_fp, mk));
}

abstract_phylum
impl_abstract_list::do_reduce(abstract_phylum neutral, abstract_phylum(*kc_fp)(abstract_phylum,abstract_phylum)) {
    abstract_phylum el = subphylum(0);
    if (!el)
	return neutral;
    abstract_list next = static_cast<abstract_list>(subphylum(1));
    return kc_fp(el,next->do_reduce(neutral,kc_fp));
}


extern const char* kc_storageclassnames[];

#ifdef KC_STATISTICS
void do_print_operator_statistics(FILE * kc_f)
{
    unsigned int kc_i;
    assertNonNull( kc_f );
    fprintf(kc_f, "%-*s| %-*s| %-*s| %-*s| %-*s| %-*s| %-*s| %-*s| %-*s| %-*s\n", 38 , "Operator", 3, "Sz", 8, "#oper", 8, "#new", 8, "#exist", 8, "#frnrec", 8, "#frrec", 8, "#freed", 8, "#rem", 9, "total (bytes)");
    fprintf(kc_f, "%-*s|%*s |%*d |%*d |%*d |%*d |%*d |%*d |%*d |%*d\n", 38, "case sensitive strings", 3, "-", 8, operator_statistics[sel__Str].created, 8, operator_statistics[sel__Str].existing_not_found, 8, operator_statistics[sel__Str].created-operator_statistics[sel__Str].existing_not_found, 8, 0, 8, 0, 8, 0, 8, 0, 9, kc_casestring_strlen);
    fprintf(kc_f, "%-*s|%*s |%*d |%*d |%*d |%*d |%*d |%*d |%*d |%*d\n", 38, "case insensitive strings", 3, "-", 8, operator_statistics[sel_NoCaseStr].created, 8, operator_statistics[sel_NoCaseStr].existing_not_found, 8, operator_statistics[sel_NoCaseStr].created-operator_statistics[sel_NoCaseStr].existing_not_found, 8, 0, 8, 0, 8, 0, 8, 0, 9, kc_nocasestring_strlen);
    for (kc_i = one_before_first_operator+1; kc_i < last_operator; kc_i++) {
	fprintf(kc_f, "%-*s|%*d |%*d |%*d |%*d |%*d |%*d |%*d |%*d |%*d\n", 38, operator_info[kc_i].name, 3, operator_info[kc_i].size, 8, operator_statistics[kc_i].created, 8, operator_statistics[kc_i].existing_not_found, 8, operator_statistics[kc_i].created-operator_statistics[kc_i].existing_not_found, 8, operator_statistics[kc_i].free_called[false], 8, operator_statistics[kc_i].free_called[true], 8, operator_statistics[kc_i].freed[false]+operator_statistics[kc_i].freed[true], 8, operator_statistics[kc_i].existing_not_found-(operator_statistics[kc_i].freed[false]+operator_statistics[kc_i].freed[true]), 9, operator_info[kc_i].size*(operator_statistics[kc_i].existing_not_found-(operator_statistics[kc_i].freed[false]+operator_statistics[kc_i].freed[true])));
    }
}
#endif // KC_STATISTICS


void
ht_static(kc_storageclass_t kc_a_storageclass_t)
{
    hashtables[kc_a_storageclass_t]->ht_static();
}

void
ht_dynamic(kc_storageclass_t kc_a_storageclass_t)
{
    hashtables[kc_a_storageclass_t]->ht_dynamic();
}

void
ht_inc_level(kc_storageclass_t kc_a_storageclass_t)
{
    hashtables[kc_a_storageclass_t]->ht_inc_level();
}

void
ht_dec_level(kc_storageclass_t kc_a_storageclass_t)
{
    hashtables[kc_a_storageclass_t]->ht_dec_level();
}

void
ht_free_level(kc_storageclass_t kc_a_storageclass_t)
{
    hashtables[kc_a_storageclass_t]->ht_free_level();
}

hashtable_t
ht_create_simple()
{
    hashtable_t kc_ht=new hashtable_struct_t;
    kc_ht->set_to_be_freed();
    return kc_ht;
}

hashtable_t
ht_assign(hashtable_t kc_a_hashtable_t, kc_storageclass_t kc_a_storageclass_t, bool still_unique)
{
    hashtable_t kc_tmp = hashtables[kc_a_storageclass_t];
    hashtables[kc_a_storageclass_t] = kc_a_hashtable_t;
    kc_storageclass_still_uniq[kc_a_storageclass_t] = still_unique;
    return kc_tmp;
}

hashtable_t
ht_assigned(kc_storageclass_t kc_a_storageclass_t)
{
    return hashtables[kc_a_storageclass_t];
}

void
ht_clear(hashtable_t kc_a_hashtable_t)
{
    kc_a_hashtable_t->ht_clear();
}

void
ht_delete(hashtable_t kc_a_hashtable_t)
{
    if(kc_a_hashtable_t->to_be_freed())
	delete kc_a_hashtable_t;
}
const char*
phylumname_or_error(enum_phyla kc_phy)
{
    if ((kc_phy <= one_before_first_phylum) || (kc_phy >= last_phylum)) {
	char *kc_strof_error;
	sprintf((kc_strof_error=new char[69]), "Internal Error: unknown phylum number: %d", kc_phy);
	return kc_strof_error;
    } else {
	return phylum_info[kc_phy].name;
    }   }


const char*
kc_operatorname_or_error(enum_operators kc_operator)
{
    if ((kc_operator <= one_before_first_operator) || (kc_operator >= last_operator)) {
	char *kc_strof_error;
	sprintf((kc_strof_error=new char[71]), "Internal Error: unknown operator number: %d", kc_operator);
	return kc_strof_error;
    } else {
	return operator_info[kc_operator].name;
    }   }


#ifndef KC_PRINTDOT_LABELSIZE
# define KC_PRINTDOT_LABELSIZE 1023
#endif

class impl_kc_dotedgenode_t
{
    public:
    impl_kc_dotedgenode_t(c_abstract_phylum from,c_abstract_phylum to, int _son_nr):
    ptr_from(from), ptr_to(to), son_nr(_son_nr), label(0), lsize(0), next(0) { }
    c_abstract_phylum ptr_from;
    c_abstract_phylum ptr_to;
    int son_nr;
    char *label;
    int lsize;
    kc_dotedgenode_t next;
};

static kc_dotedgenode_t
kc_mkdotedgenode(struct kc_dotedge_ht*, c_abstract_phylum, c_abstract_phylum, int);
static void kc_do_printdot_do_add_edge (c_abstract_phylum, c_abstract_phylum, int, int*, kc_dotedgenode_t*, const char*);
static void kc_do_printdot_subgraph_prologue (FILE*, c_abstract_phylum, const char*, const char*, bool, bool);
static void kc_do_printdot_subgraph_epilogue (FILE*);
static void kc_do_printdot_genfields (FILE*, int, bool);
static void kc_do_printdot_edges (FILE*, kc_dotedgenode_t, const char*, bool);

static bool
kc_dotedge_less(kc_dotedgenode_t p1, kc_dotedgenode_t p2)
{
    if(p2==0)
	return false;
    if(p1==0)
	return true;
    if(p1->ptr_from<p2->ptr_from)
	return true;
    if(p1->ptr_from>p2->ptr_from)
	return false;
    if(p1->ptr_to<p2->ptr_to)
	return true;
    if(p1->ptr_to>p2->ptr_to)
	return false;
    if(p1->son_nr<p2->son_nr)
	return true;
    // OPERATORHASH((unsigned) kc_phy_from);
    // OPERATORHASH((unsigned) kc_phy_to);
    return false;
}

template<typename T>
struct dotedge_less : std::binary_function<T, T, bool> {
    bool operator()(const T& X, const T& Y) const { return kc_dotedge_less(X,Y); }
};

struct kc_dotedge_ht: public std::set<kc_dotedgenode_t, dotedge_less<kc_dotedgenode_t> > {
    ~kc_dotedge_ht() {
	for(iterator i=begin();i!=end();++i)
	delete const_cast<kc_dotedgenode_t>(*i);
	clear();
    }
    kc_dotedgenode_t check_insert(kc_dotedgenode_t t) {
	std::pair<iterator,bool> res=insert(t);
	return *res.first;
    }
};

static kc_dotedge_ht* fprintdot_hashtable;
void impl_nocasestring::fprintdot(FILE *f, const char *root_label_prefix, const char *edge_label_prefix, const char *edge_attributes, bool print_node_labels, bool use_context_when_sharing_leaves, bool print_prologue_and_epilogue) const
{
    int kc_edge_nr = 1;
    kc_dotedgenode_t kc_edges = 0;
    if (print_prologue_and_epilogue) fprintdotprologue(f);
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_prologue(f, this, root_label_prefix, edge_attributes, print_node_labels, use_context_when_sharing_leaves);
    fprintdot_hashtable = new kc_dotedge_ht;
    do_printdot(f, true, &kc_edge_nr, &kc_edges, edge_label_prefix, print_node_labels, use_context_when_sharing_leaves, 0, 0);
    kc_do_printdot_edges(f, kc_edges, edge_attributes, use_context_when_sharing_leaves);
    delete fprintdot_hashtable;
    fprintdot_hashtable=0;
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_epilogue(f);
    if (print_prologue_and_epilogue) fprintdotepilogue(f);
}
void impl_casestring::fprintdot(FILE *f, const char *root_label_prefix, const char *edge_label_prefix, const char *edge_attributes, bool print_node_labels, bool use_context_when_sharing_leaves, bool print_prologue_and_epilogue) const
{
    int kc_edge_nr = 1;
    kc_dotedgenode_t kc_edges = 0;
    if (print_prologue_and_epilogue) fprintdotprologue(f);
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_prologue(f, this, root_label_prefix, edge_attributes, print_node_labels, use_context_when_sharing_leaves);
    fprintdot_hashtable = new kc_dotedge_ht;
    do_printdot(f, true, &kc_edge_nr, &kc_edges, edge_label_prefix, print_node_labels, use_context_when_sharing_leaves, 0, 0);
    kc_do_printdot_edges(f, kc_edges, edge_attributes, use_context_when_sharing_leaves);
    delete fprintdot_hashtable;
    fprintdot_hashtable=0;
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_epilogue(f);
    if (print_prologue_and_epilogue) fprintdotepilogue(f);
}
void impl_real::fprintdot(FILE *f, const char *root_label_prefix, const char *edge_label_prefix, const char *edge_attributes, bool print_node_labels, bool use_context_when_sharing_leaves, bool print_prologue_and_epilogue) const
{
    int kc_edge_nr = 1;
    kc_dotedgenode_t kc_edges = 0;
    if (print_prologue_and_epilogue) fprintdotprologue(f);
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_prologue(f, this, root_label_prefix, edge_attributes, print_node_labels, use_context_when_sharing_leaves);
    fprintdot_hashtable = new kc_dotedge_ht;
    do_printdot(f, true, &kc_edge_nr, &kc_edges, edge_label_prefix, print_node_labels, use_context_when_sharing_leaves, 0, 0);
    kc_do_printdot_edges(f, kc_edges, edge_attributes, use_context_when_sharing_leaves);
    delete fprintdot_hashtable;
    fprintdot_hashtable=0;
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_epilogue(f);
    if (print_prologue_and_epilogue) fprintdotepilogue(f);
}
void impl_integer::fprintdot(FILE *f, const char *root_label_prefix, const char *edge_label_prefix, const char *edge_attributes, bool print_node_labels, bool use_context_when_sharing_leaves, bool print_prologue_and_epilogue) const
{
    int kc_edge_nr = 1;
    kc_dotedgenode_t kc_edges = 0;
    if (print_prologue_and_epilogue) fprintdotprologue(f);
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_prologue(f, this, root_label_prefix, edge_attributes, print_node_labels, use_context_when_sharing_leaves);
    fprintdot_hashtable = new kc_dotedge_ht;
    do_printdot(f, true, &kc_edge_nr, &kc_edges, edge_label_prefix, print_node_labels, use_context_when_sharing_leaves, 0, 0);
    kc_do_printdot_edges(f, kc_edges, edge_attributes, use_context_when_sharing_leaves);
    delete fprintdot_hashtable;
    fprintdot_hashtable=0;
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_epilogue(f);
    if (print_prologue_and_epilogue) fprintdotepilogue(f);
}
void impl_voidptr::fprintdot(FILE *f, const char *root_label_prefix, const char *edge_label_prefix, const char *edge_attributes, bool print_node_labels, bool use_context_when_sharing_leaves, bool print_prologue_and_epilogue) const
{
    int kc_edge_nr = 1;
    kc_dotedgenode_t kc_edges = 0;
    if (print_prologue_and_epilogue) fprintdotprologue(f);
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_prologue(f, this, root_label_prefix, edge_attributes, print_node_labels, use_context_when_sharing_leaves);
    fprintdot_hashtable = new kc_dotedge_ht;
    do_printdot(f, true, &kc_edge_nr, &kc_edges, edge_label_prefix, print_node_labels, use_context_when_sharing_leaves, 0, 0);
    kc_do_printdot_edges(f, kc_edges, edge_attributes, use_context_when_sharing_leaves);
    delete fprintdot_hashtable;
    fprintdot_hashtable=0;
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_epilogue(f);
    if (print_prologue_and_epilogue) fprintdotepilogue(f);
}
void impl_line::fprintdot(FILE *f, const char *root_label_prefix, const char *edge_label_prefix, const char *edge_attributes, bool print_node_labels, bool use_context_when_sharing_leaves, bool print_prologue_and_epilogue) const
{
    int kc_edge_nr = 1;
    kc_dotedgenode_t kc_edges = 0;
    if (print_prologue_and_epilogue) fprintdotprologue(f);
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_prologue(f, this, root_label_prefix, edge_attributes, print_node_labels, use_context_when_sharing_leaves);
    fprintdot_hashtable = new kc_dotedge_ht;
    do_printdot(f, true, &kc_edge_nr, &kc_edges, edge_label_prefix, print_node_labels, use_context_when_sharing_leaves, 0, 0);
    kc_do_printdot_edges(f, kc_edges, edge_attributes, use_context_when_sharing_leaves);
    delete fprintdot_hashtable;
    fprintdot_hashtable=0;
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_epilogue(f);
    if (print_prologue_and_epilogue) fprintdotepilogue(f);
}
void impl_term::fprintdot(FILE *f, const char *root_label_prefix, const char *edge_label_prefix, const char *edge_attributes, bool print_node_labels, bool use_context_when_sharing_leaves, bool print_prologue_and_epilogue) const
{
    int kc_edge_nr = 1;
    kc_dotedgenode_t kc_edges = 0;
    if (print_prologue_and_epilogue) fprintdotprologue(f);
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_prologue(f, this, root_label_prefix, edge_attributes, print_node_labels, use_context_when_sharing_leaves);
    fprintdot_hashtable = new kc_dotedge_ht;
    do_printdot(f, true, &kc_edge_nr, &kc_edges, edge_label_prefix, print_node_labels, use_context_when_sharing_leaves, 0, 0);
    kc_do_printdot_edges(f, kc_edges, edge_attributes, use_context_when_sharing_leaves);
    delete fprintdot_hashtable;
    fprintdot_hashtable=0;
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_epilogue(f);
    if (print_prologue_and_epilogue) fprintdotepilogue(f);
}
void impl_expression::fprintdot(FILE *f, const char *root_label_prefix, const char *edge_label_prefix, const char *edge_attributes, bool print_node_labels, bool use_context_when_sharing_leaves, bool print_prologue_and_epilogue) const
{
    int kc_edge_nr = 1;
    kc_dotedgenode_t kc_edges = 0;
    if (print_prologue_and_epilogue) fprintdotprologue(f);
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_prologue(f, this, root_label_prefix, edge_attributes, print_node_labels, use_context_when_sharing_leaves);
    fprintdot_hashtable = new kc_dotedge_ht;
    do_printdot(f, true, &kc_edge_nr, &kc_edges, edge_label_prefix, print_node_labels, use_context_when_sharing_leaves, 0, 0);
    kc_do_printdot_edges(f, kc_edges, edge_attributes, use_context_when_sharing_leaves);
    delete fprintdot_hashtable;
    fprintdot_hashtable=0;
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_epilogue(f);
    if (print_prologue_and_epilogue) fprintdotepilogue(f);
}


kc_dotedgenode_t
kc_mkdotedgenode(kc_dotedge_ht* kc_a_ht, c_abstract_phylum kc_s_from, c_abstract_phylum kc_s_to, int kc_son_nr)
{
    kc_dotedgenode_t kc_x = new impl_kc_dotedgenode_t(kc_s_from,kc_s_to,kc_son_nr);
    kc_dotedgenode_t unique_kc_x=kc_a_ht->check_insert(kc_x);
    if(unique_kc_x!=kc_x) {
	delete kc_x;
	kc_x=unique_kc_x;
    }
    return kc_x;
}

void kc_do_printdot_subgraph_prologue(FILE *kc_f, c_abstract_phylum kc_p, const char *root_label_prefix, const char *edge_attributes, bool print_node_labels, bool use_context_when_sharing_leaves)
{
    if (!kc_f) kc_f = stdout;
    fprintf(kc_f, "/*subgraph*/ {\n");
    if (root_label_prefix) {
	fprintf(kc_f, "\"%s\" [shape=ellipse", root_label_prefix);
	if (edge_attributes && (strlen(edge_attributes) > 0)) {
	    fprintf(kc_f, ", %s", edge_attributes);
	}
	if (print_node_labels) {
	    fprintf(kc_f, ", label=\"%s\\n%s\"", root_label_prefix, phylum_info[kc_p->phylum()].name);
	}
	fprintf(kc_f, "];\n");
	fprintf(kc_f, "\"%s\" ->", root_label_prefix);
	kc_p->do_printdot_id(kc_f, use_context_when_sharing_leaves, 0, 0);
	if (edge_attributes && (strlen(edge_attributes) > 0)) {
	    fprintf(kc_f, "[%s]", edge_attributes);
	}
	fprintf(kc_f, ";\n");
    }
}

void kc_do_printdot_subgraph_epilogue(FILE *kc_f)
{
    if (!kc_f) kc_f = stdout;
    fprintf(kc_f, "}\n");
}

void fprintdotprologue(FILE *kc_f)
{
    if (!kc_f) kc_f = stdout;
    fprintf(kc_f, "digraph kc_output{\n");
    fprintf(kc_f, "node [shape=record, height=.1, fontname=Helvetica];\n");
}

void fprintdotepilogue(FILE *kc_f)
{
    if (!kc_f) kc_f = stdout;
    fprintf(kc_f, "}\n");
}

void kc_do_printdot_genfields(FILE *kc_f, int kc_prodsel, bool print_node_labels)
{
    int kc_i = 1;
    KC_OPERATOR_INFO *kc_op_info = &operator_info[kc_prodsel];
    if (kc_op_info->no_sons <= 0) return;
    if (!kc_f) kc_f = stdout;
    while(kc_i < kc_op_info->no_sons) {
	fprintf(kc_f, "<f%d>", kc_i);
	if (print_node_labels) {
	    fprintf(kc_f, "%s", phylum_info[kc_op_info->subphylum[kc_i-1]].name);
	}
	fprintf(kc_f, "|");
	kc_i++;
    }
    fprintf(kc_f, "<f%d>", kc_i);
    if (print_node_labels) {
	fprintf(kc_f, "%s", phylum_info[kc_op_info->subphylum[kc_i-1]].name);
    }
}

void impl_abstract_phylum::do_printdot_id(FILE *kc_f, bool use_context_when_sharing_leaves, c_abstract_phylum kc_ctxt, int kc_son_nr) const
{
    // The casts only make unique ids, so reinterpret_cast is alright
    if (!kc_f) kc_f = stdout;
    enum_phyla kc_phy = phylum();
    if (kc_phy == phylum_voidptr) {
	fprintf(kc_f, "kcidp%x", reinterpret_cast<int>(this));
	if (use_context_when_sharing_leaves) {
	    fprintf(kc_f, "_%x_%d", reinterpret_cast<int>(kc_ctxt), kc_son_nr);
	}
    } else if ((kc_phy == phylum_casestring) || (kc_phy == phylum_nocasestring)) {
	fprintf(kc_f, "kcids%x", reinterpret_cast<int>(this));
	if (use_context_when_sharing_leaves) {
	    fprintf(kc_f, "_%x_%d", reinterpret_cast<int>(kc_ctxt), kc_son_nr);
	}
    } else if (kc_phy == phylum_integer) {
	fprintf(kc_f, "kcidi%x", reinterpret_cast<int>(this));
	if (use_context_when_sharing_leaves) {
	    fprintf(kc_f, "_%x_%d", reinterpret_cast<int>(kc_ctxt), kc_son_nr);
	}
    } else if (kc_phy == phylum_real) {
	fprintf(kc_f, "kcidf%x", reinterpret_cast<int>(this));
	if (use_context_when_sharing_leaves) {
	    fprintf(kc_f, "_%x_%d", reinterpret_cast<int>(kc_ctxt), kc_son_nr);
	}
    } else {
	fprintf(kc_f, "kcidx%x", reinterpret_cast<int>(this));
    }   }

void kc_do_printdot_do_add_edge(c_abstract_phylum kc_p, c_abstract_phylum kc_sub_p, int kc_son_nr, int *kc_edge_nr, kc_dotedgenode_t *kc_edges, const char *edge_label_prefix)
{
    kc_dotedgenode_t kc_hn;
    char kc_buf[30];
    kc_hn = kc_mkdotedgenode(fprintdot_hashtable, kc_p, kc_sub_p, kc_son_nr);
    if (! kc_hn->label) {
	kc_hn->label = new char[(size_t)(KC_PRINTDOT_LABELSIZE+1)];
	kc_hn->lsize = KC_PRINTDOT_LABELSIZE;
	strcpy(kc_hn->label, "");
	kc_hn->next = *kc_edges;
	*kc_edges = kc_hn;
    } else {
	char kc_buf2[30];
	sprintf(kc_buf2, ", ");
	strncat(kc_hn->label, kc_buf2, kc_hn->lsize - strlen(kc_hn->label));
    }
    if (edge_label_prefix) {
	strncat(kc_hn->label, edge_label_prefix, kc_hn->lsize - strlen(kc_hn->label));
    }
    sprintf(kc_buf, "%d", *kc_edge_nr);
    strncat(kc_hn->label, kc_buf, kc_hn->lsize - strlen(kc_hn->label));
    (*kc_edge_nr)++;
}

void impl_abstract_phylum::printdot_add_edge(c_abstract_phylum kc_sub_p, int kc_son_nr, int *kc_edge_nr, kc_dotedgenode_t *kc_edges, const char *edge_label_prefix) const
{
    kc_do_printdot_do_add_edge(this, kc_sub_p, kc_son_nr, kc_edge_nr, kc_edges, edge_label_prefix);
}

void kc_do_printdot_edges(FILE *kc_f, kc_dotedgenode_t kc_edges, const char *edge_attributes, bool use_context_when_sharing_leaves)
{
    kc_dotedgenode_t kc_p = kc_edges;
    if (!kc_f) kc_f = stdout;
    while(kc_p) {
	kc_p->ptr_from->do_printdot_id(kc_f, use_context_when_sharing_leaves, 0, 0);
	fprintf(kc_f, ":f%d -> ", kc_p->son_nr);
	kc_p->ptr_to->do_printdot_id(kc_f, use_context_when_sharing_leaves, kc_p->ptr_from, kc_p->son_nr);
	fprintf(kc_f, " [label=\"%s\"", kc_p->label);
	if (edge_attributes && (strlen(edge_attributes) > 0)) {
	    fprintf(kc_f, ", %s", edge_attributes);
	}
	fprintf(kc_f, "];\n");
	kc_p = kc_p->next;
    }   }

void impl_abstract_phylum::do_printdot(FILE *kc_f, bool kc_outmost, int *kc_edge_nr, kc_dotedgenode_t *kc_edges, const char *edge_label_prefix, bool print_node_labels, bool use_context_when_sharing_leaves, c_abstract_phylum kc_ctxt, int kc_son_nr) const
{
    int kc_i;

    if (!kc_f) kc_f = stdout;
    switch(phylum()) {
	case phylum_voidptr:
	do_printdot_id(kc_f, use_context_when_sharing_leaves, kc_ctxt, kc_son_nr);
	fprintf(kc_f, " [label=\"%p\", shape=ellipse];\n", dynamic_cast<c_voidptr>(this)->pointer);
	break;
	case phylum_casestring:
	case phylum_nocasestring:
	do_printdot_id(kc_f, use_context_when_sharing_leaves, kc_ctxt, kc_son_nr);
#ifdef KC_UNICODE
	fprintf(kc_f, " [label=\"%s\", shape=ellipse];\n", kc_to_cstring(static_cast<c_casestring>(this)->name).c_str());
#else
	fprintf(kc_f, " [label=\"%s\", shape=ellipse];\n", static_cast<c_casestring>(this)->name);
#endif
	break;
	case phylum_integer:
	do_printdot_id(kc_f, use_context_when_sharing_leaves, kc_ctxt, kc_son_nr);
	fprintf(kc_f, " [label=\"%i\", shape=ellipse];\n", ((integer)this)->value);
	break;
	case phylum_real:
	do_printdot_id(kc_f, use_context_when_sharing_leaves, kc_ctxt, kc_son_nr);
	fprintf(kc_f, " [label=\"%f\", shape=ellipse];\n", ((real)this)->value);
	break;
	default:
	if (!subphylum(0)) {
	    do_printdot_id(kc_f, use_context_when_sharing_leaves, kc_ctxt, kc_son_nr);
	    fprintf(kc_f, " [label=\"<f0>%s\"];\n", op_name());
	} else {
	    do_printdot_id(kc_f, use_context_when_sharing_leaves, kc_ctxt, kc_son_nr);
	    fprintf(kc_f, " [label=\"{<f0>%s|{", op_name());
	    kc_do_printdot_genfields(kc_f, prod_sel(), print_node_labels);
	    fprintf(kc_f, "}}\"];\n");
	    abstract_phylum child;
	    for (kc_i=0; (child = subphylum(kc_i)); kc_i++) {
		printdot_add_edge(child, kc_i+1, kc_edge_nr, kc_edges, edge_label_prefix );
		child->do_printdot( kc_f, false, kc_edge_nr, kc_edges, edge_label_prefix, print_node_labels, use_context_when_sharing_leaves, this, kc_i+1 );
	    }
	}
    }
}
abstract_phylum
impl_abstract_phylum::copy(bool kc_copy_attributes) const
{
    enum_phyla kc_phy = phylum(); // XXX - implement special cases in subclasses - MvL
    KC_OPERATOR_INFO *kc_op_info = &operator_info[prod_sel()];
    kc_storageclass_t kc_st = phylum_info[kc_op_info->phylum].uniq_stored;
    if (kc_st && kc_storageclass_still_uniq[kc_st])
	return const_cast<abstract_phylum>(this);
    abstract_phylum kc_answer=0;
    if (kc_phy == phylum_casestring) {
	kc_answer=mkcasestring((dynamic_cast<c_casestring>(this))->name);
    } else if (kc_phy == phylum_nocasestring) {
	kc_answer=mknocasestring((dynamic_cast<c_nocasestring>(this))->name);
    } else if (kc_phy == phylum_voidptr) {
	kc_answer=mkvoidptr((dynamic_cast<c_voidptr>(this))->pointer);
    } else if (kc_phy == phylum_integer) {
	kc_answer=mkinteger((dynamic_cast<c_integer>(this))->value);
    } else if (kc_phy == phylum_real) {
	kc_answer=mkreal((dynamic_cast<c_real>(this))->value);
    } else {
	abstract_phylum kc_subtmp[3], child;
	for (int kc_i = 0; (child = subphylum(kc_i)); kc_i++) {
	    kc_subtmp[kc_i] = child->copy(kc_copy_attributes);
	}
	switch(kc_op_info->no_sons) {
	    case 1: kc_answer = kc_create(prod_sel(), kc_subtmp[0]); break;
	    case 2: kc_answer = kc_create(prod_sel(), kc_subtmp[0], kc_subtmp[1]); break;
	    case 3: kc_answer = kc_create(prod_sel(), kc_subtmp[0], kc_subtmp[1], kc_subtmp[2]); break;
	    default: assertionFailed("unexpected number of sub-phyla");
	}
    }
    if (kc_copy_attributes)
	copy_attributes(kc_phy, this, kc_answer);
    return kc_answer;
}


} // namespace kc
